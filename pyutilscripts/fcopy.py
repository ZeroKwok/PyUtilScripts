#! python
# -*- coding: utf-8 -*-
#
# This file is part of the PyUtilScripts project.
# Copyright (c) 2020-2025 zero <zero.kwok@foxmail.com>
#
# For the full copyright and license information, please view the LICENSE
# file that was distributed with this source code.
#
# ###
#
# 1. 以tree -aif命令输出的内容作为文件清单(如下).
# 2. 通过脚本将(directory)原目录下的匹配文件, 拷贝到(output)目标目录.
#
# 语法如下
# fcopy.py [-l,--list FILE] [-d,--directory DIRECTORY] <-o,--output DIRECTORY>
#
# CMD
# python fcopy.py -l ../fcopy.list -d . -o "\\192.168.1.230\2024-01-26 1625"

import os
import re
import sys
import stat
import click
import shutil
import filecmp
import difflib
import argparse
import datetime
import traceback
from   pathlib import Path
from   natsort import natsorted
from   datetime import datetime, timezone
from   termcolor import colored, cprint

CopyModes = ["update", "overwrite", "rename", "interactive", "u", "o", "r", "i"]

ListFileHeader ="""# File list generated by fcopy on {}
# One file per line, relative to source directory
"""

ActionsFileHeader = """# Action plan for file copying (edit this file to change actions)
# Actions: copy (c), skip (s)
#
# Example:
# c file1.txt                   Copy or Overwrite
# c file3.txt -> file(3).txt    Copy or overwrite, then rename to file(3).txt
# s file2.txt                   Skip
"""

def read_file_list(filename, comment='#', keep_comments=False):
    """Read the list of files to copy from the manifest file."""
    with open(filename, 'r') as f:
        lines = [line.strip() for line in f.readlines()]

    # Filter out comments and empty lines
    files = []
    for line in lines:
        if not keep_comments:
            if line.startswith(comment) or not line:
                continue
        files.append(line)
    return files

def make_file_list(source):
    files = []
    for root, _, names in os.walk(source):
        for n in names:
            filename = os.path.join(root, n)
            filename = os.path.relpath(filename, start=source)
            files.append(filename)

    date = datetime.now().isoformat(timespec='seconds')
    head = ListFileHeader.format(date).splitlines()
    return head + natsorted(files)

def update_file_list(args):
    """Update the file list with the current contents of the source directory."""
    new = make_file_list(args.source)
    old = []
    if os.path.exists(args.list):
        with open(args.list, 'r') as f:
            old = [line.strip() for line in f.readlines()]

    # 生成 unified diff
    diff = difflib.unified_diff(
        old,
        new,
        fromfile=args.list + ' (old)',
        tofile=args.list + ' (new)',
        lineterm=''
    )

    # 对 diff 行进行彩色渲染
    print('')
    for line in diff:
        if line.startswith('+'):
            cprint(line, 'green')  # 新增行：绿色
        elif line.startswith('-'):
            cprint(line, 'red')    # 删除行：红色
        elif line.startswith('@@'):
            cprint(line, 'cyan')   # 差异位置标记：青色
        else:
            cprint(line)

    # Ask for confirmation
    cprint(f"\nUpdate {args.list} with these changes? [y/N]", end=" ")
    confirm = input().strip().lower()
    if confirm != 'y':
        cprint('User Cancelled', 'red')
        raise SystemExit()

    with open(args.list, 'w') as f:
        f.write('\n'.join(new))

def file_cmp(stat1, stat2):
    # 比较文件大小和修改时间
    if stat1.st_size == stat2.st_size and stat1.st_mtime == stat2.st_mtime:
        return 0
    if stat1.st_mtime >= stat2.st_mtime:
        return 1
    else:
        return -1

def increment_filename(directory, filename):
    """
    在指定目录中为给定文件名生成不冲突的新文件名（仅文件名部分，不含路径）。
    支持多扩展名（如 .tar.gz）及已有的 (1)、(2) 递增模式。
    """
    directory = Path(directory)
    stem, *suffixes = filename.split('.')
    suffix = '.' + '.'.join(suffixes) if suffixes else ''

    # 若 stem 形如 "file(1)"，则提取基础名与编号
    match = re.match(r'^(.*?)(\((\d+)\))?$', stem )
    if match:
        stem = match.group(1)
        number = int(match.group(3)) if match.group(3) else 0
    else:
        number = 0

    # 初始候选
    candidate = filename
    while (directory / candidate).exists():
        number += 1
        candidate = f"{stem}({number}){suffix}"

    return candidate

def parse_actions(lines, comment='#'):
    files = []
    for row, line in enumerate(lines):
        if ' ' not in line:
            raise ValueError(f"Invalid line: {row}: {line}")

        # Handle action-prefixed lines (for edit mode)
        action, files = line.split(' ', 1)
        if line.startswith(comment) or not line or action.startswith('s'):
            continue

        if '->' in line:
            file1, file2 = line.split('->', 1)
            if not file2.strip():
                raise ValueError(f"Invalid line: {row}: {line}")
        else:
            file1, file2 = (line, '')
        files.append((file1.strip(), file2.strip()))
    return files

def read_file_actions(filename, comment='#'):
    return parse_actions(read_file_list(filename, comment, True), comment)

def make_file_actions(args):
    items = []
    for file in args.manifest:
        source = os.path.normpath(os.path.join(args.source, file))
        target = os.path.normpath(os.path.join(args.target, file))
        
        stat1 = os.stat(source)
        try:
            stat2 = os.stat(target)
        except FileNotFoundError:
            items.append(('c', file, ''))
            continue

        if args.mode in ('r', 'rename'):
            file2 = increment_filename(args.target, file)
            items.append((args.mode, file, file2))
            continue

        diff = file_cmp(stat1, stat2)
        if diff > 0:
            items.append(('c', file, ''))
        else:
            items.append(('s', file, ''))
    return items

def edit_actions(actions:list, header:str) -> list:
    """
    使用 click.edit() 启动编辑器让用户编辑行动计划。
    返回: None 用户取消编辑或没保存
    """
    content = header.rstrip() + "\n" + "\n".join(actions) + "\n"

    # 打开编辑器让用户编辑内容（会用系统默认编辑器或 $EDITOR）
    edited = click.edit(content, extension=".actionplan")
    if edited is None:
        cprint("User canceled or didn't save, Aborting.")
        raise SystemExit()

    # 解析用户编辑后的结果
    return parse_actions(edited.splitlines(), '#')

def copy_files(args):
    """Copy files from source directory to target directory with specified manifest"""
    # 读取清单
    manifest = read_file_list(args.list)
    if manifest is None:
        cprint('Error: list file is empty or invalid.', 'red')
        return

    # 生成文件操作列表
    actions = make_file_actions(args)
    actions = edit_actions(actions, ActionsFileHeader)
    
    for item in actions:
        if item[0] == 's':
            continue
        if item[0] == 'c':
            source = os.path.normpath(os.path.join(args.source, item[1]))
            target = os.path.normpath(os.path.join(args.target, item[2] if item[2] else item[1]))
            os.makedirs(os.path.dirname(args.target), exist_ok=True)
            shutil.copy2(source, target)

def main():
    try:
        parser = argparse.ArgumentParser(
            description="Copy files from source directory to target directory with flexible copy modes.", 
            formatter_class=argparse.ArgumentDefaultsHelpFormatter)
        parser = argparse.ArgumentParser(description='Copy files from source directory to target directory.')
        parser.add_argument('-l', '--list', default='fcopy.list', help='File containing the list of files to copy.')
        parser.add_argument("-s", "--source", required=True, help="source directory containing files to copy")
        parser.add_argument("-t", "--target", help="target directory where files will be copied")
        parser.add_argument("-m", "--mode", default="update", choices=CopyModes, help="copy mode: u|update, o|overwrite, r|rename, i|interactive")
        parser.add_argument("-v", "--verbose", action="count", default=0, help="increase verbosity level (use -vv for more detail)")
        parser.add_argument("--update-list", action="store_true", help="update the --list file with current --source contents (with confirmation)")
        parser.add_argument("--dry-run", action="store_true", help="simulate operations without actually copying files")
        parser.add_argument('--debug', action='store_true', default=False, help=argparse.SUPPRESS)

        try:
            args = parser.parse_args()
        except SystemExit:
            print('\n'.join(parser.format_help().splitlines()[1:]))
            return

        # argparse 默认会保留字符串中的引号
        for key in args.__dict__:
            if type(args.__dict__[key]) == str:
                args.__dict__[key] = args.__dict__[key].strip(' \'"')

        if args.debug:
            input('Wait for debugging and press Enter to continue...')
        if not args.list or not args.source:
            print("Error: Please provide the required arguments.")
            parser.print_help()
            return

        args.mode = args.mode.lower()
        if not os.path.isdir(args.source):
            print(f"Error: Source directory '{args.source}' does not exist")
            return

        if args.update_list:
            update_file_list(args)
        else:
            copy_files(args)

    except KeyboardInterrupt:
        cprint('\nKeyboard Interrupt', 'red', end='')

if __name__ == "__main__":
    main()
