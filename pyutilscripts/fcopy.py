#! python
# -*- coding: utf-8 -*-
#
# This file is part of the PyUtilScripts project.
# Copyright (c) 2020-2025 zero <zero.kwok@foxmail.com>
#
# For the full copyright and license information, please view the LICENSE
# file that was distributed with this source code.
#
# ###
#
# 1. 以tree -aif命令输出的内容作为文件清单(如下).
# 2. 通过脚本将(directory)原目录下的匹配文件, 拷贝到(output)目标目录.
#
# 语法如下
# fcopy.py [-l,--list FILE] [-d,--directory DIRECTORY] <-o,--output DIRECTORY>
#
# CMD
# python fcopy.py -l ../fcopy.list -d . -o "\\192.168.1.230\2024-01-26 1625"

import os
import re
import sys
import stat
import shlex
import click
import shutil
import filecmp
import difflib
import argparse
import datetime
import traceback
from   pathlib import Path
from   natsort import natsorted
from   datetime import datetime, timezone
from   termcolor import colored, cprint

CopyModes = ["update", "overwrite", "rename", "interactive", "u", "o", "r", "i"]

ListFileHeader ="""# File list generated by fcopy on {}
# One file per line, relative to source directory
"""

ActionsFileHeader = """# Action plan for file copying (edit this file to change actions)
# Actions: copy (c), overwrite (o), skip (s)
#
# Example:
# c file1.txt                   Copy
# c file3.txt -> file(3).txt    Copy and Rename to file(3).txt
# o file2.txt                   Overwrite
# s file2.txt                   Skip
"""

def read_file_list(filename, comment='#', keep_comments=False):
    """Read the list of files to copy from the manifest file."""
    if filename is None:
        return None
    with open(filename, 'r') as f:
        lines = [line.strip() for line in f.readlines()]

    # Filter out comments and empty lines
    files = []
    for line in lines:
        if not keep_comments:
            if line.startswith(comment) or not line:
                continue
        files.append(line)
    return files

def make_file_list(source):
    files = []
    for root, _, names in os.walk(source):
        for n in names:
            filename = os.path.join(root, n)
            filename = os.path.relpath(filename, start=source)
            files.append(filename)

    date = datetime.now().isoformat(timespec='seconds')
    head = ListFileHeader.format(date).splitlines()
    return head + natsorted(files)

def update_file_list(args):
    """Update the file list with the current contents of the source directory."""
    new = make_file_list(args.source)
    old = []
    if os.path.exists(args.list):
        with open(args.list, 'r') as f:
            old = [line.strip() for line in f.readlines()]

    # 生成 unified diff
    diff = difflib.unified_diff(
        old,
        new,
        fromfile=args.list + ' (old)',
        tofile=args.list + ' (new)',
        lineterm=''
    )

    # 对 diff 行进行彩色渲染
    print('')
    for line in diff:
        if line.startswith('+'):
            cprint(line, 'green')  # 新增行：绿色
        elif line.startswith('-'):
            cprint(line, 'red')    # 删除行：红色
        elif line.startswith('@@'):
            cprint(line, 'cyan')   # 差异位置标记：青色
        else:
            cprint(line)

    # Ask for confirmation
    cprint(f"\nUpdate {args.list} with these changes? [y/N]", end=" ")
    confirm = input().strip().lower()
    if confirm != 'y':
        cprint('User Cancelled', 'red')
        raise SystemExit()

    with open(args.list, 'w') as f:
        f.write('\n'.join(new))

def file_cmp(stat1, stat2):
    # 比较文件大小和修改时间
    if stat1.st_size == stat2.st_size and stat1.st_mtime == stat2.st_mtime:
        return 0
    if stat1.st_mtime >= stat2.st_mtime:
        return 1
    else:
        return -1

def increment_filename(directory, filename):
    """
    在指定目录中为给定文件名生成不冲突的新文件名（仅文件名部分，不含路径）。
    支持多扩展名（如 .tar.gz）及已有的 (1)、(2) 递增模式。
    """
    directory = Path(directory)
    stem, *suffixes = filename.split('.')
    suffix = '.' + '.'.join(suffixes) if suffixes else ''

    # 若 stem 形如 "file(1)"，则提取基础名与编号
    match = re.match(r'^(.*?)(\((\d+)\))?$', stem )
    if match:
        stem = match.group(1)
        number = int(match.group(3)) if match.group(3) else 0
    else:
        number = 0

    # 初始候选
    candidate = filename
    while (directory / candidate).exists():
        number += 1
        candidate = f"{stem}({number}){suffix}"

    return candidate

def make_actions(args):
    items = []
    for file in args.manifest:
        source = os.path.normpath(os.path.join(args.source, file))
        target = os.path.normpath(os.path.join(args.target, file))

        stat1 = os.stat(source)
        try:
            stat2 = os.stat(target)
        except FileNotFoundError:
            items.append(('c', file, ''))
            continue

        if args.mode in ('r', 'rename'):
            file2 = increment_filename(args.target, file)
            items.append(('c', file, file2))
            continue

        elif args.mode in ('o', 'overwrite'):
            items.append(('o', file, ''))
            continue

        diff = file_cmp(stat1, stat2)
        if diff > 0:
            items.append(('o', file, ''))
        else:
            items.append(('s', file, ''))
    return natsorted(items)

def parse_actions(lines, comment='#'):
    files = []
    for row, line in enumerate(lines):
        line = line.strip()
        if not line or line.startswith(comment):
            continue

        # Handle action-prefixed lines (for edit mode)
        if ' ' not in line:
            raise ValueError(f"Invalid line: {row}: {line}")

        if '->'in line:
            fields = shlex.split(line, posix=os.name != 'nt')
        else:
            fields = line.split(maxsplit=1)

        if len(fields) == 2: 
            action, file1, file2 = fields + ['']
        elif len(fields) == 4 and '->' in fields:
            action, file1, _, file2 = fields
        else:
            raise ValueError(f"Invalid line: {row}: {line}, parse as: {fields}")
        files.append((action, file1.strip(' \'"'), file2.strip(' \'"')))

    return files

def read_file_actions(filename, comment='#'):
    return parse_actions(read_file_list(filename, comment, True), comment)

def get_available_editor(defaults=("micro", "nano", "vim", "vi", "notepad")):
    """检查哪个编辑器可用，返回第一个可用的，否则返回 None"""
    if "EDITOR" in os.environ:
        defaults.insert(0, os.environ["EDITOR"])
        cprint(f'Preferred editor detected: {defaults[0]}', 'yellow')
    for editor in defaults:
        if shutil.which(editor):  # 检查是否在 PATH 里
            return editor
    return None

def join_actions(actions:list, header:str, verbose:int):
    lines = []
    for item in actions:
        line = f'{item[0]}  "{item[1]}"'
        if item[2]:
            line += f' -> "{item[2]}"'
        lines.append(line)
    return header.rstrip() + "\n\n" + "\n".join(lines) + "\n"

def edit_actions(actions:list, header:str, verbose:int) -> list:
    """
    使用 click.edit() 启动编辑器让用户编辑行动计划。
    返回: None 用户取消编辑或没保存
    """
    content = join_actions(actions, header, verbose)

    # 打开编辑器让用户编辑内容
    edited = click.edit(content, extension=".actions-todo", editor=get_available_editor())
    if edited is None:
        cprint("User canceled or didn't save, aborted.", "red")
        raise SystemExit()

    # 解析用户编辑后的结果
    return parse_actions(edited.splitlines(), '#')

def print_actions(actions:list, header:str, verbose:int):
    print()
    cprint(f"The following actions will be performed:", "yellow")
    lines = join_actions(actions, header, verbose)
    for line in lines.splitlines():
        if not line:
            print()
            continue

        a = line[0]
        c = {"#": "dark_grey", "s": "yellow", "o": "green", "c": "green", " ": "white"}
        f = a if a in c else " "
        cprint(line, c[f])
    print()

def copy_files(args):
    """Copy files from source directory to target directory with specified manifest"""

    # 读取清单
    args.manifest = read_file_list(args.list)
    if args.manifest is None:
        cprint('Error: list file is empty or invalid.', 'red')
        raise SystemExit()

    # 生成文件操作列表
    actions = make_actions(args)
    if args.interactive:
        actions = edit_actions(actions, ActionsFileHeader, args.verbose)
    elif args.dry_run or args.verbose > 1:
        print_actions(actions, ActionsFileHeader, args.verbose)

    copied, skipped = (0, 0)
    for item in actions:
        if item[0] == 's':
            skipped += 1
            continue

        if item[0] in ('c', 'o', 'r'):
            source = os.path.normpath(os.path.join(args.source, item[1]))
            target = os.path.normpath(os.path.join(args.target, item[2] if item[2] else item[1]))

            prefix = {'c' : 'Copy      ', 'o': 'Overwrite', 'r': 'Rename   '}[item[0]]
            if args.dry_run:
                cprint(f"Dry run: {prefix}: {source} -> {target}", "cyan")
            elif args.verbose > 0:
                cprint(f"{prefix}: {source} -> {target}", 'green')
            else:
                cprint(f"{prefix}: {item[1]}", 'green')

            if not args.dry_run:
                os.makedirs(os.path.dirname(target), exist_ok=True)
                shutil.copy2(source, target)
            copied += 1
    cprint(f"Done. {copied} files copied, {skipped} skipped.")

def main():
    try:
        parser = argparse.ArgumentParser(
            description="Copy files from source directory to target directory with flexible copy modes.", 
            formatter_class=argparse.ArgumentDefaultsHelpFormatter)
        parser = argparse.ArgumentParser(description='Copy files from source directory to target directory.')
        parser.add_argument('-l', '--list', default='fcopy.list', help='File containing the list of files to copy.')
        parser.add_argument("-s", "--source", required=True, help="source directory containing files to copy")
        parser.add_argument("-t", "--target", help="target directory where files will be copied")
        parser.add_argument("-m", "--mode", default="update", choices=CopyModes, help="copy mode: u|update, o|overwrite, r|rename")
        parser.add_argument("-i", "--interactive", action="store_true", help="Let the user edit the list of action plans to copy")
        parser.add_argument("-v", "--verbose", action="count", default=0, help="increase verbosity level (use -vv for more detail)")
        parser.add_argument("--update-list", action="store_true", help="update the --list file with current --source contents (with confirmation)")
        parser.add_argument("--dry-run", action="store_true", help="simulate operations without actually copying files")
        parser.add_argument('--debug', action='store_true', default=False, help=argparse.SUPPRESS)

        try:
            args = parser.parse_args()
        except SystemExit:
            print('\n'.join(parser.format_help().splitlines()[1:]))
            return

        # argparse 默认会保留字符串中的引号
        for key in args.__dict__:
            if type(args.__dict__[key]) == str:
                args.__dict__[key] = args.__dict__[key].strip(' \'"')

        if args.debug:
            args.verbose = 2
            input('Wait for debugging and press Enter to continue...')

        if not args.list or not args.source:
            print("Error: Please provide the required arguments.")
            parser.print_help()
            return

        args.mode = args.mode.lower()
        args.source = os.path.normpath(os.path.abspath(args.source))
        if not os.path.isdir(args.source):
            print(f"Error: Source directory '{args.source}' does not exist")
            return

        if args.update_list:
            update_file_list(args)
        else:
            if args.target is None:
                cprint(f"Error: Please provide the target directory.")
                return
            args.target = os.path.normpath(os.path.abspath(args.target))
            copy_files(args)

    except KeyboardInterrupt:
        cprint('\nKeyboard Interrupt', 'red', end='')

if __name__ == "__main__":
    main()
